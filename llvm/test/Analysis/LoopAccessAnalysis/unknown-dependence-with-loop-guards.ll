; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes='print<access-info>' -disable-output %s 2>&1 | FileCheck %s

define void @unsafe_dep_loopguards(ptr %a, ptr %b, ptr %c) {
; CHECK-LABEL: 'unsafe_dep_loopguards'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop. Use #pragma clang loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
; CHECK-NEXT:  Unknown data dependence.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        Unknown:
; CHECK-NEXT:            %ld.a = load [4 x i32], ptr %gep.a.offset.2, align 4 ->
; CHECK-NEXT:            store i32 0, ptr %gep.a.offset.4, align 4
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Check 0:
; CHECK-NEXT:        Comparing group GRP0:
; CHECK-NEXT:        ptr %c
; CHECK-NEXT:        Against group GRP1:
; CHECK-NEXT:          %gep.a.offset.2 = getelementptr i32, ptr %gep.a.offset, i32 4
; CHECK-NEXT:      Check 1:
; CHECK-NEXT:        Comparing group GRP0:
; CHECK-NEXT:        ptr %c
; CHECK-NEXT:        Against group GRP2:
; CHECK-NEXT:          %gep.a.offset.4 = getelementptr i32, ptr %a, i32 %offset.4
; CHECK-NEXT:      Grouped accesses:
; CHECK-NEXT:        Group GRP0:
; CHECK-NEXT:          (Low: %c High: (16 + %c))
; CHECK-NEXT:            Member: %c
; CHECK-NEXT:        Group GRP1:
; CHECK-NEXT:          (Low: (16 + (4 * (sext i32 %ld.b to i64))<nsw> + %a) High: (64 + (4 * (sext i32 %ld.b to i64))<nsw> + %a))
; CHECK-NEXT:            Member: {(16 + (4 * (sext i32 %ld.b to i64))<nsw> + %a),+,32}<%loop>
; CHECK-NEXT:        Group GRP2:
; CHECK-NEXT:          (Low: ((4 * (sext i32 (4 + %ld.b) to i64))<nsw> + %a) High: (36 + (4 * (sext i32 (4 + %ld.b) to i64))<nsw> + %a))
; CHECK-NEXT:            Member: {((4 * (sext i32 (4 + %ld.b) to i64))<nsw> + %a),+,32}<%loop>
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-NEXT:      {(4 + %ld.b),+,8}<nw><%loop> Added Flags: <nssw>
; CHECK-NEXT:      {((4 * (sext i32 (4 + %ld.b) to i64))<nsw> + %a),+,32}<%loop> Added Flags: <nusw>
; CHECK-NEXT:      {%ld.b,+,8}<nw><%loop> Added Flags: <nssw>
; CHECK-NEXT:      {(16 + (4 * (sext i32 %ld.b to i64))<nsw> + %a),+,32}<%loop> Added Flags: <nusw>
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
; CHECK-NEXT:      [PSE] %gep.a.offset.2 = getelementptr i32, ptr %gep.a.offset, i32 4:
; CHECK-NEXT:        (16 + (4 * (sext i32 {%ld.b,+,8}<nw><%loop> to i64))<nsw> + %a)
; CHECK-NEXT:        --> {(16 + (4 * (sext i32 %ld.b to i64))<nsw> + %a),+,32}<%loop>
; CHECK-NEXT:      [PSE] %gep.a.offset.4 = getelementptr i32, ptr %a, i32 %offset.4:
; CHECK-NEXT:        ((4 * (sext i32 {(4 + %ld.b),+,8}<nw><%loop> to i64))<nsw> + %a)
; CHECK-NEXT:        --> {((4 * (sext i32 (4 + %ld.b) to i64))<nsw> + %a),+,32}<%loop>
;
entry:
  %ld.b = load i32, ptr %b
  %guard.cond = icmp slt i32 0, %ld.b
  br i1 %guard.cond, label %exit, label %loop

loop:
  %iv = phi i32 [ %iv.next, %loop ], [ 0, %entry ]
  %offset = add i32 %ld.b, %iv
  %gep.a.offset = getelementptr i32, ptr %a, i32 %offset
  %gep.a.offset.2 = getelementptr i32, ptr %gep.a.offset, i32 4
  %ld.a = load [4 x i32], ptr %gep.a.offset.2
  store [4 x i32] %ld.a, ptr %c
  %offset.4 = add i32 %offset, 4
  %gep.a.offset.4 = getelementptr i32, ptr %a, i32 %offset.4
  store i32 0, ptr %gep.a.offset.4
  %iv.next = add i32 %iv, 8
  %exit.cond = icmp eq i32 %iv.next, 16
  br i1 %exit.cond, label %exit, label %loop

exit:
  ret void
}

define void @safe_with_rtchecks_loopguards(i16 %n, ptr %p3, i16 noundef %q, ptr %p1, ptr %p2) {
; CHECK-LABEL: 'safe_with_rtchecks_loopguards'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Memory dependences are safe with run-time checks
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Check 0:
; CHECK-NEXT:        Comparing group GRP0:
; CHECK-NEXT:          %arrayidx22 = getelementptr inbounds [2 x i32], ptr %alloca, i16 %iv
; CHECK-NEXT:        Against group GRP1:
; CHECK-NEXT:          %arrayidx33 = getelementptr inbounds i8, ptr %arrayidx22, i16 4
; CHECK-NEXT:      Check 1:
; CHECK-NEXT:        Comparing group GRP0:
; CHECK-NEXT:          %arrayidx22 = getelementptr inbounds [2 x i32], ptr %alloca, i16 %iv
; CHECK-NEXT:        Against group GRP2:
; CHECK-NEXT:          %arrayidx42 = getelementptr inbounds [2 x i32], ptr %arrayidx40, i16 %iv
; CHECK-NEXT:      Check 2:
; CHECK-NEXT:        Comparing group GRP0:
; CHECK-NEXT:          %arrayidx22 = getelementptr inbounds [2 x i32], ptr %alloca, i16 %iv
; CHECK-NEXT:        Against group GRP3:
; CHECK-NEXT:          %arrayidx53 = getelementptr inbounds i8, ptr %arrayidx42, i16 4
; CHECK-NEXT:      Check 3:
; CHECK-NEXT:        Comparing group GRP1:
; CHECK-NEXT:          %arrayidx33 = getelementptr inbounds i8, ptr %arrayidx22, i16 4
; CHECK-NEXT:        Against group GRP2:
; CHECK-NEXT:          %arrayidx42 = getelementptr inbounds [2 x i32], ptr %arrayidx40, i16 %iv
; CHECK-NEXT:      Check 4:
; CHECK-NEXT:        Comparing group GRP1:
; CHECK-NEXT:          %arrayidx33 = getelementptr inbounds i8, ptr %arrayidx22, i16 4
; CHECK-NEXT:        Against group GRP3:
; CHECK-NEXT:          %arrayidx53 = getelementptr inbounds i8, ptr %arrayidx42, i16 4
; CHECK-NEXT:      Check 5:
; CHECK-NEXT:        Comparing group GRP2:
; CHECK-NEXT:          %arrayidx42 = getelementptr inbounds [2 x i32], ptr %arrayidx40, i16 %iv
; CHECK-NEXT:        Against group GRP3:
; CHECK-NEXT:          %arrayidx53 = getelementptr inbounds i8, ptr %arrayidx42, i16 4
; CHECK-NEXT:      Grouped accesses:
; CHECK-NEXT:        Group GRP0:
; CHECK-NEXT:          (Low: %alloca High: (4 + (8 * (zext i16 (-1 + %n) to i64))<nuw><nsw> + %alloca))
; CHECK-NEXT:            Member: {%alloca,+,8}<nuw><%loop>
; CHECK-NEXT:        Group GRP1:
; CHECK-NEXT:          (Low: (4 + %alloca) High: (8 + (8 * (zext i16 (-1 + %n) to i64))<nuw><nsw> + %alloca))
; CHECK-NEXT:            Member: {(4 + %alloca),+,8}<nuw><%loop>
; CHECK-NEXT:        Group GRP2:
; CHECK-NEXT:          (Low: ((8 * (sext i16 %n to i64))<nsw> + %alloca) High: (4 + (8 * (zext i16 (-1 + %n) to i64))<nuw><nsw> + (8 * (sext i16 %n to i64))<nsw> + %alloca))
; CHECK-NEXT:            Member: {((8 * (sext i16 %n to i64))<nsw> + %alloca),+,8}<nw><%loop>
; CHECK-NEXT:        Group GRP3:
; CHECK-NEXT:          (Low: (4 + (8 * (sext i16 %n to i64))<nsw> + %alloca) High: (8 + (8 * (zext i16 (-1 + %n) to i64))<nuw><nsw> + (8 * (sext i16 %n to i64))<nsw> + %alloca))
; CHECK-NEXT:            Member: {(4 + (8 * (sext i16 %n to i64))<nsw> + %alloca),+,8}<nw><%loop>
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %0 = shl i16 %n, 1
  %alloca = alloca [2 x i32], i16 %0
  %arrayidx1 = getelementptr inbounds i32, ptr %p1, i16 %q
  %arrayidx2 = getelementptr inbounds i8, ptr %p3, i16 2
  %arrayidx4 = getelementptr inbounds i32, ptr %p2, i16 %q
  %cmp42 = icmp sgt i16 %n, 0
  br i1 %cmp42, label %ph, label %exit

ph:
  %arrayidx40 = getelementptr inbounds [2 x i32], ptr %alloca, i16 %n
  br label %loop

loop:
  %iv = phi i16 [ 0, %ph ], [ %iv.next, %loop ]
  %arrayidx6 = getelementptr inbounds i32, ptr %arrayidx1, i16 %iv
  %arrayidx11 = getelementptr inbounds i32, ptr %arrayidx4, i16 %iv
  %arrayidx22 = getelementptr inbounds [2 x i32], ptr %alloca, i16 %iv
  store i32 10, ptr %arrayidx22
  %arrayidx33 = getelementptr inbounds i8, ptr %arrayidx22, i16 4
  store i32 16, ptr %arrayidx33
  %arrayidx42 = getelementptr inbounds [2 x i32], ptr %arrayidx40, i16 %iv
  store i32 19, ptr %arrayidx42
  %arrayidx53 = getelementptr inbounds i8, ptr %arrayidx42, i16 4
  store i32 23, ptr %arrayidx53
  %iv.next = add nuw nsw i16 %iv, 1
  %exitcond.not = icmp eq i16 %iv.next, %n
  br i1 %exitcond.not, label %exit, label %loop

exit:
  ret void
}
